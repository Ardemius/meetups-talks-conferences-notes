= 2023/06/01 - JavaDay au Paris JUG: Le futur de Java en 2023
Thomas SCHWENDER <icon:github[] https://github.com/Ardemius/[GitHub] / icon:twitter[role="aqua"] https://twitter.com/thomasschwender[@thomasschwender]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images
:source-highlighter: highlightjs
:highlightjs-languages: asciidoc
// We must enable experimental attribute to display Keyboard, button, and menu macros
:experimental:
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 4
// To number the sections of the table of contents
//:sectnums:
// Add an anchor with hyperlink before the section title
:sectanchors:
// To turn off figure caption labels and numbers
:figure-caption!:
// Same for examples
//:example-caption!:
// To turn off ALL captions
// :caption:

toc::[]

* JavaDay organis√© par le Paris JUG, au centre des congr√®s du Jardin d'Acclimatation, le 2023/06/01
* Description de l'√©v√®nement : https://javaday.parisjug.org/
* Programme : https://javaday.parisjug.org/schedule.html

== 09h15 : Accueil des participants

== 10h00 : Jean-Michel Doudoux : En route vers Java 21

=== Abstract

Passionn√© par le d√©veloppement de logiciels et par la veille technologique, je poss√®de une longue exp√©rience, en SSII/ESN et personnelle, dans l‚Äô√©criture d‚Äôapplications avec diff√©rents langages. Je suis actuellement Senior tech lead pour la soci√©t√© Sciam. Utilisant Java depuis sa version 1.0, j‚Äôaime partager ma passion pour cette plateforme et son √©cosyst√®me notamment en me consacrant, depuis presque vingt ann√©es, √† la r√©daction de deux tutoriels, intitul√©s ‚ÄúD√©veloppons en Java‚Äù, diffus√©s sous licence GNU FDL. Ce travail m‚Äôa permis d‚Äô√™tre nomm√© Java Champion. Je suis √©galement un des cofondateurs du Lorraine JUG.

En attendant la publication de Java 21, la prochaine version diffus√©e en septembre de cette ann√©e, et pour en donner quelques aper√ßus, cette pr√©sentation brosse une revue d√©taill√©e des nouveaut√©s qui devraient √™tre propos√©es dans cette future version LTS de Java, issues des projets Amber, Loom et Panama d‚ÄôOpenJDK.

=== Notes

* 2023 : Java 21 version LTS, version cible pour les entreprises
    ** rappel : r√©duction de 3 √† 2 ans entre 2 LTS apr√®s JAva 17

* Java 21 : 13 nouvelles JEP d√©j√† cibl√©es +
image:20230601_Javaday_01.jpg[]

* Projet *Amber* :

    ** r√¥le : d√©velopper la syntaxe

    ** Les *Record Patterns* deviennent standard
        *** On rajoute un pattern qui va permettre de faire de la d√©construction de Record

    ** Le *Pattern Matching* devient √©galement standard dans une instruction switch
        *** avec support de la valeur null contrairement √† la lev√©e historique d'une NPE

    ** JEP 430 : *String Templates* en preview
        *** but : enrichir le langage Java avec es string templates
            **** qui compl√®tent les cha√Ænes litt√©rales et les blocs de texte en combinant : 
                ***** un texte litt√©ral avec des expressions int√©gr√©es
                ***** et un processeur de templates
            **** pour produire des cha√Ænes de caract√®res construites dynamiquement

.Template expressions
image:20230601_Javaday_02.jpg[]

    ** JEP 443 : *Unnamed patterns* and variables
        *** enrichit le langage d'une syntaxe pour les patterns inutilis√©s dans les record pattern imbriqu√©s et les variables inutilis√©es qui doivent √™tre d√©clar√©es
        *** utilise le 51 op√©rateur de Java introduit avec Java 9 : "_"

image:20230601_Javaday_03.jpg[]

    ** *Unnamed classes* and *Instance Main* methods
        *** Exemple avec la r√©√©criture simplifi√©e de notre "bon vieux Hello World" +
        image:20230601_Javaday_04.jpg[]

* Projet *Loom* : 
    ** but : explorer, incuber et fournier des fonctionnalit√©s (JVM et API) pour prendre en charge une concurrence l√©g√®re, facile √† utiliser et √† haut d√©bit
    ** ainsi que de nouveau mod√®les de programmation concurrente.

    ** *Virtual Threads* : threads l√©gers, g√©r√©s par la JVM, doivent devenir standards avec Java 21
    ** *Structured Concurrency* : nouveau mod√®le de programmation pour simplifier la programmation multithread
        *** sera en preview en Java 21 (JEP 453 proposed to target)
    ** *Scoped Values*
        *** pour partager des objets dans le code ex√©cut√© par un thread, on utilisait jusqu'√† maintenant une variable de type ThreadLocal
            **** cela √©vite de devoir passer des param√®tres au thread

image:20230601_Javaday_05.jpg[]

* Projet *Panama* :

    ** *Foreign function & memory API* : API de bas niveau pour de mani√®re, s√ªre et efficace : 
        *** acc√©der √† des donn√©es en m√©moire hors du tas (off heap memory)
        *** invoquer des fonctions natives

image:20230601_Javaday_06.jpg[]

    ** *Vector API* : exprimer des calculs vectoriels
        *** qui, au moment de l'ex√©cution, sont syst√©matiquement compil√©s
        *** ave les meilleures instructions vectorielles possibles sur l'architectures xxx (SIMD ?)

* Evolutions des API de Java Core

    ** Sequenced collections : +
    image:20230601_Javaday_07.jpg[]
    image:20230601_Javaday_08.jpg[]
    
* Evolutions dans la JVM HotSpot : 

    ** generational ZGC : donc avec des objets √† dur√©e de vie longue et √† dur√©e de vie courte
    ** generational Shenandoah

.Conclusion
image:20230601_Javaday_09.jpg[]

* L'√©cosyst√®me Java en 2023 : beaucoup de nouveaut√©s pr√©sent√©es dans les prochains talks de la journ√©e

    **Jakarta EE 10 et Microprofile 6.0
    ** Spring Boot 3 et xxx

*Q&A* : 

    * Pour une migration de Java 8 √† Java 21, les plus durs n'est PAS le passage aux derni√®res LTS, MAIS le passage √† *Java 11*

== 10h50 : Antoine Sabot-Durant : Les nouveaut√©s de Jakarta EE 10 et Microprofile 6.0

=== Abstract 

Antoine est un Java Champion et l‚Äôancien spec lead de Jakarta EE CDI. Il a fait partie de l‚Äô√©quipe de lancement de Quarkus chez Red Hat et √† travaill√© sur des specs MicroProfile majeures comme Fault Tolerance ou Health Check. Aujourd‚Äôhui, Antoine est architecte et expert technique chez SCIAM. Il pilote des projets complexes en utilisant en grande partie les technologies qu‚Äôil a contribu√© √† mette au point.

La derni√®re mouture de Jakarta EE est arriv√©e en fin d‚Äôann√©e derni√®re. Sortie enfin de la migration Java EE vers Jakarta EE, cette nouvelle √©dition apporte de r√©elles nouveaut√©s utilisables telles quelles ou dans votre stack pr√©f√©r√©e comme MicroProfile, Quarkus ou m√™me Spring (!). Au m√™me moment Microprofile 6.0 est √©galement arriv√© dans un repository pr√®s de chez vous. Cette nouvelle √©dition s‚Äôappuie directement sur Jakarta EE 10 pour simplifier son socle et proposer de nouvelles fonctionnalit√©s. Dans cette pr√©sentation nous passerons en revues les principales nouveaut√©s de ces 2 stacks majeures. Puis non √©voquerons les √©volutions pr√©sentent et √† venir sur les frameworks ou produits qui les impl√©mentent.

=== Notes

* *Jakarta EE* is a set of vendor's neutral, open specifications that are used for developing modern, cloud compatible applications from the ground.
    ** specifications documentation
    ** specifications code & API
    ** specifications TCK

.J2EE, Java EE, Jakarta EE Timeline
image:20230601_Javaday_10.jpg[]

* Initialement il y a avait 10 specs, maintenant il y en a 30

* Spring : "c'est propos√© un truc qui fonctionne mieux et soit plus facile d'usage que JEE"
    ** D'o√π Java EE 5 sorti en r√©action en 2006
        *** "on va faire EJB 3.0 pour √©liminer les probl√®mes des pr√©c√©dents EJB". +
        Mais la comm c'est capital, et corriger les erreurs pass√©es MAIS garder le m√™me nom "EJB", ce n'est pas la meilleure des id√©es

* Java EE 8 √† Jakarta EE 8 : 2 ans de "d√©m√©nagement" pour passer de Oracle √† la fondation Eclipse

* Jakarta EE 10 en 2022 : facilite l'interaction avec MicroProfile

.Jakarta EE 10 in a nutshell
image:20230601_Javaday_11.jpg[]

    * grosse nouveaut√© : apparition de CDI Lite (qui reste inclus dans CDI "classique")

Comme ces 30 specs repr√©sentent au final quelque chose d'assez lourd, des profiles ont √©t√© cr√©√©s : 

.Web Profile
image:20230601_Javaday_12.jpg[]

.Core Profile : pour microservices et applications Cloud native
image:20230601_Javaday_13.jpg[]

    * Le Core Profile est le r√©sultat d'une collaboration avec l'√©quipe MicroProfile
    * Accent mis sur l'int√©gration / l'utilisation (??? A VERIFIER) de frameworks Quarkus, Helidon, Micronaute afin de produire du code l√©ger et tr√®s performant.

* CDI : √©quivalent de Spring mais dans JEE, Context Dependency Injection

.What is CDI Lite ?
image:20230601_Javaday_14.jpg[]

    ** Main goal : r√©duire l'empreinte m√©moire et CPU et la taille de l'ex√©cutable de fa√ßon tr√®s significative tout en conservant un maximum de la "magie" de CDI
    ** Pour rappel, Quarkus a √©t√© d√©velopp√© par RedHat, et CDI est une sp√©cification RedHat...
        *** De l√† √† dire qu'on a chang√© la spec CDI pour l'adapter √† Quarkus... (ben il y a un peu de cela, mais un peu seulement)
        *** Il y a eu une r√©flexion pour s'assurer que CDI Lite n'allait pas fonctionner QUE avec Quarkus
            **** Les √©quipes de Micronaute, puis plus tard d'Oracle pour Helidon, ont particip√© √† la d√©finition de CDI Lite

.What is NOT in CDI Lite ?
image:20230601_Javaday_15.jpg[]

    * Pas de d√©corateur
    * Tout ce qu'on fait dans CDI Lite, on sait le faire dans CDI "full". +
    CDI Lite est vraiment un sous-ensemble de CDI full

.Build time compatible extension
image:20230601_Javaday_16.jpg[]

.De nombreuses impl√©mentations de Jakarta EE de disponible
image:20230601_Javaday_17.jpg[]

* ET, Spring utilise 22 spec Jakarta EE sur les 30... (C'est donc la pire impl√©mentation disponible de Jakarta EE) +
image:20230601_Javaday_18.jpg[]

*D√©finition de Microprofile* : an open specifications stack to optimize Entreprise java fo a microservices architecture by collaborating on common areas of interest with the goal of standardization.

.Microprofile Timeline
image:20230601_Javaday_19.jpg[]

    * 1 release majeure tous les ans
    * 1 interm√©diaire tous les 6 mois

-> La *cible de Microprofile* est bien le *Cloud*.

* Initialement Microprofile a √©t√© annonc√© pour concurrencer Spring Boot.

.Spec Microprofile 6.0
image:20230601_Javaday_20.jpg[]

Open Telemetry a remplac√© Open Tracing dans Microprofile 6.0, ce dernier est pass√© en "outside umbrella / standalone"

== 11h40 : Brian Clozel : Spring Boot 3, GraalVM et images natives

=== Abstract

Brian est membre de l‚Äô√©quipe Spring chez VMware. Il travaille sur le Spring Framework, sur Spring GraphQL et sur Spring Boot.

Comment compiler une application Spring en code natif et profiter d‚Äôun temps de d√©marrage rapide et d‚Äôune consommation m√©moire r√©duite ? Pendant cette session, nous vous pr√©senterons le moteur AOT qui permet aux applications Spring d‚Äôadopter la technologie GraalVM Native images. Comment proc√©der, quelles sont les limitations, comment participer √† la communaut√© GraalVM ? Nous √©voquerons tous ces points en utilisant une application exemple.

=== Notes

.Pourquoi passer en natif ?
image:20230601_Javaday_21.jpg[]

.Les use cases pour des images native
image:20230601_Javaday_22.jpg[]
image:20230601_Javaday_23.jpg[]

Dans Spring Boot 3 on va introduire une phase de compilation interm√©diaire : +
image:20230601_Javaday_24.jpg[]

.Principe de "closed world"
image:20230601_Javaday_25.jpg[]

* Il faut √©viter de manipuler du Bytecode au runtime, le cas ne s'y pr√™te pas, on va souffrir pour pas grand chose

.GraalVM native image
image:20230601_Javaday_26.jpg[]

Conseil : Essayer de d√©l√©guer au plus tard la cr√©ation de l'image native, au plus proche de la PROD

*  Observabilit√© : gros travail de fait c√¥t√© SPring √† ce niveau 
    ** Plut√¥t que de passer par un agent externe pour le monitoring, passer par les fonctionnalit√©s d√©j√† mise √† disposition par Spring

* Nouvelle version GraalVM 23.0
    ** convergence entre GraalVM et le JDK
        *** Bient√¥t la version de GraalVM sera simplement la version du JDK

* Dans l'√©quipe Spring, il y a un travail en cours sur *Checkpoint / Restore* (l'autre nom de CRaC)
    ** POur red√©marrer en quelques ms la JVM dans l'√©tat exact o√π elle √©tait pr√©c√©demment.

.GraalVM & CRaC tradeoffs
image:20230601_Javaday_27.jpg[]

Conclusion : *Spring : being part of the GraalVM community*

== 14h00 : Lilian Benoit : CRaC vs GraalVM, pour un d√©marrage rapide

=== Abstract

Lilian est Tech Leader dans une ESN Bordelaise. il est passionn√© par l‚Äôinformatique depuis bien plus longtemps. Il aime travailler sur la plateforme Java (Java SE et Jakarta EE), d‚Äôautant plus sur sa distribution de pr√©dilection : Debian. Il adore apprendre et partager ses connaissances. C‚Äôest comme cela qui s‚Äôest rapproch√© du BordeauxJUG dont il en est JUG Leader depuis 2016. L‚Äôobjectif du Bordeaux JUG est de promouvoir Java √† travers des soir√©es/conf√©rences mensuelles autour de la plateforme Java.

Dans les cas d‚Äôusages modernes (Kubernetes, Serverless), tout le monde sait que le point noir de la JVM est son d√©marrage. Depuis quelques ann√©es, GraalVM s‚Äôimpose comme r√©m√®de permettant ainsi un d√©marrage rapide via une compilation native. Cela apporte n√©anmoins certaines contraintes. Une nouvelle solution apparait dans le paysage de la JVM. C‚Äôest CRaC pour Coordinated Restore at Checkpoint. Regardons ensemble comment cela fonctionne et les avantages.

=== Notes

Lilian : 

    * Mastodon : @lilian_Benoit@jvm.social
    * Twitter : @Lilian_Benoit

Changement de paradigme : besoin d'un d√©marrage rapide des applications (microservices, applications Cloud native, etc.)

* Fonctionnement de la JVM : 
    ** Bytecode interpr√©t√©
    ** le code "pr√©chauffe"
    ** compilateur C1 et C2 du JIT

* Usage de Java
    ** chargement des classes et chargeur de classes
    ** prise en compte des annotations (ex: Entity) : magique pour les d√©veloppeurs, mais une charge de plus pour la JVM !
    ** initialisation des blocs statiques
        *** Les fameux blocs entre "\{ \]" que l'on rappelle de ne PAS faire (mauvaise pratique, ces blocs sont charg√©s au d√©but de la classe)
    ** initialisation du contexte applicatif (CDI ou Spring)

* GraalVM : une solution propos√©e par Oracle Labs
    ** compilateur Graal qui remplace le compilateur Java classique

* L'int√©r√™t est de faire un checkpoint une fois que la JVM a bien "chauff√©" et que le JIT a optimis√© le code.
    ** Par contre, il faudrait faire attention √† ne pas faire de checkpoint au cours de certaines op√©rations de la JVM
    ** Pour le restore, il faut vraiment que ce dernier soit fait sur une machine IDENTIQUE : classes au m√™me endroit, modules du noyau, ET il faut que ce soit sur Unix (pas sur Windows ni sur MAC)
        *** donc faire une image (Docker) sur distro Redhab et la r√©tablir sur Debian sera difficile (il faudra que tout le kernel et ce qui gravite autour soit identique)
    ** TODO : il faudrait recreuser toutes ces explications... üòÖ

.Fonctionnement pour la partie native image
image:20230601_Javaday_28.jpg[]

CRaC : Coodinated Restore and Chekkpoint

.Synth√®se : GraalVM native image vs CRaC JVM image
image:20230601_Javaday_29.jpg[]

== 14h50 : Herv√© Bout√©my : Software Supply Chain, SBOM et signature avec Maven

=== Abstract

Herv√© est Committer Maven depuis 2007, Maven PMC Chair de 2014 √† 2016. Il est membre de la Fondation Apache depuis 2011, Apache Community Development, actuel VP Apache Attic.

Ghost, Dirty cow, Log4Shell, Heart Bleed ont tous fait fr√©mir nos managers et occup√© pas mal de nos nuits d‚Äôastreinte. Cela a eu suffisamment d‚Äôimportance pour que les Etats Unis imposent la livraison d‚Äôun SBOM avec nos logiciels pour renforcer la ma√Ætrise de la ‚ÄúSoftware Supply Chain‚Äù. Et les attaques sur cette Supply Chain relancent la n√©cessit√© de la signature, qui √©videmment ne peut pas se faire √† l‚Äôancienne comme au si√®cle dernier. Comme souvent, il ne s‚Äôagit pas tant de technologie que d‚Äôhabitude et d‚Äôhygi√®ne que l‚Äôoutillage doit faciliter. Parcourons ensemble ces questions et comment Maven peut vous faire entrer dans le cercle vertueux.

=== Notes

.Explication au sujet de la Software Supply Chain
image:20230601_Javaday_30.jpg[]

* La majorit√© des probl√®mes de vuln√©rabilit√©s sont introduits au travers de *d√©pendances transitives*.

*PARTIE SBOM :*

* SBOM : *Software Bill of Materials*
    ** si on devait vouloir traduire cette expression, ce serait avec un concept "d'*inventaire*"
        *** SBOMs are hierarchical lists of content
    ** Le SBoM est la base de la ma√Ætrise de la Supply Chain : toute personne qui d√©veloppe un logiciel devrait √™tre capable de fournir son SBoM

.BoMs in traditional Supply Chains
image:20230601_Javaday_31.jpg[]

Les 2 plus gros standards de SBOMs : *CycloneDX* (OWASP) et *SPDX* (Fondation Linux)

.CycloneDX (cr√©ation en 2019)
image:20230601_Javaday_32.jpg[]

.SBOM n'est "PAS" Maven
WARNING: SBOM != Maven BOM POM 

.BOM POM
image:20230601_Javaday_33.jpg[]

* le BOM POM repr√©sente ce que l'on POURRAIT utiliser et le SBOM est ce que utilise r√©ellement
    ** Le BOM POM est une notion cr√©√©e avec le SBOM, mais en termes d'adoption (merci le gouvernement am√©ricain...), c'est bien le SBOM qui a gagn√©.

.Sonatype BOM Doctor
image:20230601_Javaday_34.jpg[]

*PARTIE SIGNATURE :*

* PGP vs Sigstore
    ** PGP (Pretty Good Privacy) : la signature "√† l'ancienne"

* *Sigstore* : sa promesse est "d'oublier les cl√©s √† la PGP"
    ** l'objectif est d'oublier toute la probl√©matique de gestion des cl√©s
    ** Sigstore : easy "keyless" signature
    ** son 1er march√© : le mone Kubernetes

.Sigstore
image:20230601_Javaday_35.jpg[]

-> Il va falloir √† ce que tous les √©cosyst√®mes int√®grent Sigstore pour le d√©ploiement d'artifacts (en plus ou en remplacement des cl√©s PGP)

.Keyless signing workflow
image:20230601_Javaday_36.jpg[]

    * Identit√© fournit par OpenID Connect
    * Fulcio va fournir un certificat valable 10 min
        ** "c'est bien moi qui est sign√© durant les 10 min o√π le certificat √©tait valide"

Demo sur programme d'illustration complet cr√©√© par Herv√© ("sigstore-poc-0.1.0" ???)

image:20230601_Javaday_37.jpg[]
image:20230601_Javaday_38.jpg[]

C'est l'infrastructure classique de Sigstore que Herv√© a utilis√© : 

image:20230601_Javaday_39.jpg[]

* Le service Sigstore est actuellement g√©r√© par Google et une universit√© am√©ricaine.
    ** il est h√©berg√© sur du GCP

* Si on veut "faire sa propre infra Sigstore", attention, ce n'est pas si √©vident que cela...
    ** Par d√©faut, le mieux est d'utiliser l'infra Sigstore publique

.Architecture applicative de Sigstore
image:20230601_Javaday_40.jpg[]

Sigstore et Maven : 

    * sigstore-java-library
    * sigstore-maven-plugin

Maven Central : PGP + sigstore

== 16h00 : R√©mi Forax : La programmation concurrente structur√©e : un scoop sur les scopes

=== Abstract

Loom en preview, c‚Äôest fini ; les threads virtuels d√©barquent en tant que fonctionnalit√© officielle de Java 21, la prochaine LTS. Les performances des API asynchrones sans utiliser de Mono, Flux et autres Multi. Comme d‚Äôhabitude, d√®s qu‚Äôon a une grosse fonctionnalit√© en Java, tout le monde regarde de pr√®s le code. L√†, on se rend compte qu‚Äôen fait, l‚ÄôAPI des Executor n‚Äôest pas si bien que cela, surtout maintenant qu‚Äôon a des threads virtuels. Et si on imaginait une nouvelle API synchrone pour faire du calcul asynchrone en utilisant les principes de la programmation concurrente structur√©e. Dans ce talk, apr√®s une rapide explication de ce qu‚Äôest un thread virtuel, j‚Äôexpliquerai quel est le principe d‚Äôune API concurrente structur√©e, l‚ÄôAPI pr√©vue en Java 21 et les am√©liorations pr√©vues pour Java 22.

== 16h50 : Panel de discussions avec les speakers





