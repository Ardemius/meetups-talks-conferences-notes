= Voxxed days Microservices
Thomas SCHWENDER <https://github.com/ardemius[@ardemius]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: images
:source-highlighter: highlightjs
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 2
// To turn off figure caption labels and numbers
//:figure-caption!:
// Same for examples
//:example-caption!:
// To turn off ALL captions
:caption:

toc::[]

Du 29 au 31/10/2018, à l'espace Charenton à Paris.

* *Site* : https://voxxeddays.com/microservices/
* *Schedule* : https://vxdms2018.confinabox.com/talks/conf

== MONDAY

*Schedule* : https://vxdms2018.confinabox.com/byday/mon

=== Welcome to Voxxed Days Microservices

Presented by Antonio GONCALVES.

Pour les tables rondes (panel), on peut poser des questions aux panelistes via les hashtages `#MicroServices` and `#panel`

.Plan de lieux et sponsors
image::voxxed_place_map.jpg[]

*Wifi* : SSID "Espace Charenton Fibre" : / mdp : CharentonfibreFibre#Paris12

Parmi les partenaires :

* Manning : on *ctwvoxxed18* pour avoir 40% de réduction sur tous les livres Manning
* Comme pour Devoxx France, *321IdCom* est partenaire pour la comm de l'évènement (c'est une des boîtes utilisée pour les goodies de Devoxx France)

*Twitter* : @vxdmicroservice

=== Distant Past of Microservices

Presentedy by *Ken Finnigan*, Senior Principal Software Engineer for *Red Hat* Middleware.

==== Abstract

Microservices, distributed systems in sheep's clothing, have been around in various forms since the 1960s! We trek down amnesia lane, finding that what we’re doing has been done before, but the names and tools have changed.

Whether it’s Netflix OSS, Spring Cloud, or any other open source framework for microservices, we’ve likely experienced using them all at one point. What have using these frameworks taught us? Do they help or hinder us? Is Service Mesh the answer? I’ll explore these questions as we meander along a journey through the past.

==== Notes

When speaking of microservices, we are speaking of *distributed systems*

Ken : client / server architecture is just another distributed system

*Characteristics of microservices* :

* retries
* transaction manager
* Command objects
* service registry
* caching

Ken cite (comme tout le monde) *Istio* pour la gestion de l'environnement associé aux microservices.

[quote, Ken]
____
We have to stop reinventing the same wheel, just because we can...
____

.Consistent state
image::voxxed_01.jpg[]

Ken vient de "Enterprise Java Microservices" chez Manning.

=== distributed: of systems and teams

Presented by *Bridget Kromhout*, Principal Cloud Developer Advocate at Microsoft.

==== Abstract

We endeavor to build consistency, availability, and fault tolerance into our distributed systems, but how do we build them into our teams? The human factors in microservices require as much attention as do our technical implementations.

Drawing in comparisons from theoretical computer science and practical systems implementation, I’ll explore how building understanding requires a practical application of great tools in a deliberate pursuit of a constructive culture.

==== Notes

____
We replace our monolith with microservices so that every outage could be more like a murder mystery
____

.CAP theorem
image::voxxed_02.jpg[]

.Reminder
NOTE: *CAP theorem* : trade-off between *Consistency / Availability / partition tolerance*

==== Consistency

Bridget remembering a startup going to Docker in PROD in 2013 (!). +
For which reasons? -> *more consistent deployments, more repeatable ones*

Containers don't solve all problems

*Helm*: the package manager for Kubernetes +
"Help is the best way to find, share, and use software built for Kubernetes"

image::voxxed_03.jpg[]

==== Availability

Kubernetes: a choice for orchestration 

* portable
* extensible
* self-healing

Tools to check : *Draft*, *Brigade*, *Virtual Kubelet*

.Virtual Kubelet
image::voxxed_04.jpg[]

Orchestrating containers is a tool, *NOT* a goal! +
-> If no benefit, don't do it

==== Partition tolerance (or Fault tolerance)

[quote, Loi de Conway]
____
Any organization that designs a system.... will produce a design whose structure is a copy of the organization's *communication* structure
____

* *Monitoring* is for operating software/systems
* *Insturmentation* is for wrting software
* *observability* is for understanding systems.

_Winter is coming_ -> k8s getting real

=== Preparing For a Future Microservices Journey

Presented by Susanne Kaiser, independent Tech Consultant.

==== Abstract

In the light of rapidly changing market requirements organizations must accelerate to excel in the market. A 4-years research (by Nicole Forsgren, Jez Humble and Gene Kim) has revealed that software delivery performance has a strong impact on profitability, productivity and market share of technology organizations. +
Loosely coupled architecture, such as promoted by microservices, and empowered teams are some of the capabilities to improve software delivery performance. 

After having already introduced microservices in a startup context I would like to share some thoughts what to do differently when introducing microservices next time in the future.

==== Notes

Quite a journey to move to monolith to microservices

.Microservices required components
image::voxxed_05.jpg[]

____
Build the things that differentiate you, offload the things that don't
____

.Cloud native
image::voxxed_06.jpg[]

.Kubernetes
image::voxxed_07.jpg[]

.Cloud native citizen principles
image::voxxed_08.jpg[]

Importance of the separation of concerns -> with the use of *Service Mesh*

image::voxxed_09.jpg[]

And now *Serverless* principles

image:voxxed_10.jpg[]
image:voxxed_11.jpg[]

.Serverless example with image processing
image::voxxed_12.jpg[]

=== Hexagonal at Scale, with DDD and microservices!

Presented by Cyrille MARTRAIRE, CTO and partner at Arolla.

==== Abstract

*Microservices need DDD absolutely*. +
Bounded Contexts, a key DDD ingredient, is the tool of choice to define services boundaries that won’t end up in a complete disaster at runtime and at deployment time. And for a given service, the Hexagonal Architecture is a great implementation style as well.

In this talk, you’ll get a deeper understanding of what these abstract buzzwords are all about, illustrated with short Java code. You’ll discover how to really split your monolith correctly, and when to go Hexagonal, or not, because one should never abuse of the good things. It will be fun, with perhaps a few surprises as well!

==== Notes

* Split by technology +
Also wrong...
* Split by entity +
Still wrong, even if the most common...

So how to define our Bounded Contexts correctly? +
*By (sub-)domain*

image::voxxed_13.jpg[]

-> This alignment is just what we want. +
But we only know *afterwards* that our boundaries where right

We want to partition things into *independent* things.

*Strategic design* = in the *long* term

See this example, with a very bad add of a 2nd address in the class :

image::voxxed_14.jpg[] 

-> At term, it will *NOT* be maintainable.

In this other example : Customer is not Account is not Recipient, EVENT IF THEY LOOK LIKE EACH OTHER! +
*not to be* means (most of the time) different Bounded Contexts.

-> *DRY PLUS coupling OR isolation PLUS redundancy*

In the former customer, account, recipient factorizing common attributes (like address) means coupling. +
Moreover, it is not because things look like each other that they are the same thing (meaning the same BC) +
-> duplication (same address in several different BC) can be a good thing or even a required thing.

.High coupling and low cohesion
image::voxxed_15.jpg[]

Every pb on a coupled element will propagate to the whole application.

With this alternative, we now only rely on "shipping" -> low coupling, better cohesion

image::voxxed_16.jpg[]

Mapping = ACL (Anti COrruption Layer) in DDD

.Good and bad architecture
image::voxxed_17.jpg[]

Now, how do we identify the Bounded Contexts?

* DIfferent Company Departments -> different Bounded Contexts
* Different USAGE of the same thing -> different Bounded Contexts
+
image::voxxed_18.jpg[]

Like in a dictionary, a same word can have different meanings in different contexts.

image::voxxed_19.jpg[]

Good domains generally end with "-ing" or "-tion" (because *purpose verbs* made into nouns)

When using Event Storming, do it for *Big Things*

image::voxxed_20.jpg[]

* "Search" is always a bounded context on its own.
* Same thing for "Reporting"

Do not mandatorily split your monolith *too soon*, wait a bit to know it better

===== Hexagonal architecture

Indeed a good thing, but introduce some complexity.

To compensate that:

* Hexagonal light
* CRUD: most of the time, instead of unnecessary complexity, go CRUD!

To illustrate the need for isolation, and so microservices

image::voxxed_21.jpg[]

-> on the right, if something goes rotten, it will not contaminate the other things

You can also have *BFF* (Backend for Frontend)

*CONCLUSION*: Invest some time in learning DDD, hexagonal architecture, because they are fundamentals and reusable skills

=== Accelerate your CI/CD on Kubernetes with Jenkins X

Presented by *James Strachan*, one of the founders of Jenkins X, also created the Groovy programming language and the Apache Camel integration framework.

==== Abstract

We all want to become high performing teams delivering real business value quickly! This talk will show you how you can go faster by automating:

* setting up your CI/CD so you can spin up new microservices in seconds
* packaging of your application as container images and helm charts so it can be deployed easily on any cluster
* automatic or manual promotion of your application through Testing, Staging and Production via GitOps
* using Preview environments to get fast feedback on code changes at Pull Request before you merge them and without blocking urgent bug fixes

After watching this talk you should be able to accelerate your delivery of microservices and go faster!

==== Notes

Advise of James: read _The science of DevOps - ACCELERATE_

.Capabilities of Jenkins X
image::voxxed_22.jpg[]

* Use version control for all artifacts
* automate your deployment process
* use *trunk based* development
* implement continuous integration
* implement continuous delivery
* use loosely coupled architecture

.How does Jenkins X help?
image::voxxed_23.jpg[]

.Install process of Jenkins X: different ways
image::voxxed_24.jpg[]

-> it uses *Google Kubernetes Engine*

.Advise from James
NOTE: : Try to *avoid mini-kube*, go straight to the cloud (as soon as possible)

What's the result? +
-> each team gets their own:

* Dev Tools environment
	** jenkins master
	** elastic pool of Kubernetes build pods
	** *Nexus + monocular (Helm application store)*
* stating env
* production env

.Different ways of importing and creating projects
image::voxxed_25.jpg[]

Pour la démo, voir le projet sur le repo GitHub de James (directement), _voxxedms_ (in repo _jstrachan_)

IMPORTANT: James insiste sur l'intérêt de faire un max de test sur les branches de PR plutôt que sur le master (qui peut-être broken)

image::voxxed_26.jpg[]

.Resources
image::voxxed_27.jpg[]

-> in those links, there is the one of their very active Slack channel

NOTE: James, comme bien d'autres, fait ses slides sur la suite Google. +
De plus en plus, on se retrouve soit avec des slides Asciidoctor, soit avec des slides Google

=== Stop reinventing the wheel with Istio

Presented by *Mete Atamel*, a Developer Advocate at Google, focused on helping developers with Google Cloud.

==== Abtract

Containers provide a consistent and reproducible environment to run our services. +
Orchestration systems like Kubernetes help us to manage and scale our container cluster with a consistent API. +
This is a good start for a loosely coupled microservices architecture but it is not enough. 

How do you control the flow of traffic and enforce policies between services? How do you visualize service dependencies and quickly identify issues? How can you provide verifiable service identities, handle and test for failures? +
You can implement your own custom solutions or you can rely on Istio, an open platform to connect, manage and secure microservices. 

In this talk, we will take a look at some of the key capabilities of Istio and see how it can help with your microservices network.

==== Notes

The need for *Istio*

1st a reminder about containers:

image::voxxed_28.jpg[]

But *containers are not enough*:

image::voxxed_29.jpg[]

And hence the use of *Kubernetes*

image::voxxed_30.jpg[]

-> Kubernetes manages *applications*, NOT machines

Finally, for *microservices in Kubernetes world*:

image::voxxed_31.jpg[]

But *Kubernetes is not enough either*!

image::voxxed_32.jpg[]

And so we have *Istio*: +
-> *An open framework for connecting, securing, managing and monitoring services*.

Its goal:

* community maturing and gathering around common tools
* decouple application code from underlying platform and policies

.Service architecture with Istio
image::voxxed_33.jpg[]

To have Istio, first you need to have a Kubernetes cluster.

.Istio in one slide
image::voxxed_34.jpg[]

* metrics can be seen with Graphana
* trace spans with Zipkin

.Istio architecture
image::voxxed_35.jpg[]

* On voit l'usage de *Envoy* (à la place de Zuul ou Ribbon)

image::voxxed_36.jpg[]
image::voxxed_37.jpg[]

We can install Istio without all its components (without dealing with Mixer or Pilot by example)

Gateway is where you accept traffic in your service mesh.

Istio add-ons

* Graphana
* Jaeger / Zipkin

Istio features:

image::voxxed_38.jpg[]

[NOTE]
====
*New Routing API*: only from v1alph3 (O.8.0)

image::voxxed_39.jpg[]
====

*Resources*:

image::voxxed_40.jpg[]

=== Data in a Microservices world: from conundrum to options

Presented by *Emmanuel BERNARD*, Chief Architect for data stuff at Red Hat Middleware, and *Madou COULIBALY*.

==== Abtract

Microservices are great, problems arise when you start to have two of them and when you want to deal with data :)

Pun aside, data and state is a big subject that is largely ignored when discussing Microservices.

* Conundrum #1 : What is the aimed data architecture in a perfect Microservices architecture?
* Conundrum #2 : How do you share state between instances of a given Microservice in a stateless 12 factor approach?
* Conundrum #3 : how to echange state between Microservices that must remain independent?
* Conundrum #4 : how do I go from my brownfield database to a fleet of Microservices IRL without a Big Bang?
* Conundrum #5 : with many Microservices touching many data sets, how do I guarantee uniformed security (GDPR anyone)?

And the list goes on. This presentation is an opinionated answer to these questions. And yes we do demo these concepts.

==== Notes

.Microservices architecture benefits
image::voxxed_41.jpg[]

Monolith to microservices +
-> To data velocity

Benefits of *data virtualization* (here with *Teiid*) :

image:voxxed_42.jpg[]
image:voxxed_43.jpg[]

* Virtual DB doesn't really store data

image::voxxed_44.jpg[]

* Still with this last schema, if we wan't to rollback, we didn't touch the legacy DB

Now *Data security*, important point today, especially because of *regulatory constraints*

image:voxxed_45.jpg[]
image:voxxed_46.jpg[]

* main piece here is *data firewall*

===== Demo (breaking the monolith)

image::voxxed_47.jpg[]

.Breaking up the monolithic database *virtually*
image::voxxed_48.jpg[]

The *virtual DB* is defined with an XML file.

The whole demo is deployed on OpenShift.

Our microservices will be built on top of those virtual DBs.

===== how do we share the state in a stateless application?

.the challenge of state
image::voxxed_49.jpg[]

-> there is a service to do that (with *Infinispan*)

image:voxxed_50.jpg[]
image:voxxed_51.jpg[]

-> *advantages*: complexity outside the app / low latency / cross data center replication

===== Caching

As says Emmanuel: _One service to fail them all..._

-> Again, use a service to do that (still Infinispan)

image::voxxed_52.jpg[]

===== CQRS and more

Now that we went a bit further in our migration towards microservices, let's consider the following:

image::voxxed_53.jpg[]

*CDC* (Change Data Capture) to the rescue

image::voxxed_54.jpg[]

* *Debezium* is based on *Kafka* and *Kafka Connect* (check the "Real time DB change (CDC)" in the last schema)

*Conclusion*:

image::voxxed_55.jpg[]

* Take a pragmatic approach and *break up large data sources logically*
* delegate data handling to specialized services (out of the app)

.Resources
image::voxxed_56.jpg[]

=== Habitat: Automation that travels with the app

Presented by *Romain Sertelon*

==== Abstract

There are a plethora of build tools and package managers out in the universe, but no one way to ensure a happy path from local development to production when you have a micro service architecture.

This talk explains why Habitat was created, as an open source application automation engine, and how you can use it to build and ship your applications to any infrastructure with the same guarantees.

We'll go over existing build tools, their pro's and con's, industry best practices, and what Habitat adds to the mix.

==== Notes

Context at Habitat: migration from monolith to microservices

* 4 years
* 2 developpers
* simplest infrastructure possible
	** 2 envs
	** 8 services
	** "container" tarballs
	** manual deployment each sprint

More was needed on the *infra side*:

* "no more SSH"
* config management
* continuous deployment
* infrastructure agnostic tooling (to adapt easily to infra changes)

And hence the use of *Habitat project*, which is *backed by CHEF*.

.Habitat innovative vision (application automation)
image::voxxed_57.jpg[]

How is it done:

* Encapsulates and automates your application
* package management

Docker is the only thing required as prerequisite by Habitat.

.Conclusion
image:voxxed_58.jpg[]
image:voxxed_59.jpg[]

== TUESDAY

*Schedule* : https://vxdms2018.confinabox.com/byday/tue

=== Reactive design patterns for microservices on multicore

Presented by *Charly Bechara*, and *Alain Habra* from Tredzone

==== Abstract

Most of the challenges encountered when designing microservices are solved using concurrent design patterns. However, these patterns usually do not take into account the multicore issues and possible optimizations. +
This is a hard requirement for *real-time mission-critical applications*, such as a *trading platform*.

This talk will cover best practices for building Reactive design patterns optimized for multicore. +
To achieve this, we’ll be using the *actor model* as implemented in our runtime *Simplx*: https://github.com/Tredzone/simplx

We will present use-cases related to our experience working with Euronext on the next generation trading platform. +
We will show how to obtain throughput scalability with the number of cores, while keeping the end-to-end latency stable.

C/C++ and Java knowledge is helpful but not required to enjoy this talk.

==== Notes

*Tredzone* : high problematics of performances

3 parts (categories for the following patterns) :

* Microservices on multicore
* monitoring 

image::voxxed_60.jpg[]

* have a special look at the "fast data" part of the graph

More and more several microservices can now run on the same CPU socket (instead of 1 microservice per CPU socket) -> because of the evolution of hardware

.cores per CPU socket
image::voxxed_61.jpg[]

2 parameters that impact *scalability* :

* Contention 
* Coherency

image::voxxed_62.jpg[]

* No contention on the private cache
* *MESI* protocol is the way to copy data from a private cache to another (*cache coherency*) 

image::voxxed_63.jpg[]

* Share multiple actors per cores
* use of an *Event Loop* with Simplx (a runtime)

What is Simplx?

image::voxxed_64.jpg[]

Very good resources (books) :

* _Reactive messaqging patterns with the actor model_
* _Reactive design patterns_ (roland kuhn)

*Pattern 1: The core-aware messaging pattern*

image::voxxed_65.jpg[]

* core / socket / server for the not so visible legend

*Sometimes* (meaning not always) synchronous direct call are better than pushing an asynchronous message +
-> 100 times faster

*Pattern 2: the message mutualization pattern*

image::voxxed_66.jpg[]

* left: 3 events / right: 1 event and 3 direct calls

*Pattern 4: the core usage pattern*

image::voxxed_67.jpg[]

* Detect overloading cores before it's too late

*Pattern 5: the queuing prevention pattern*

* other example of monitoring
* purpose: avoid the "my destination can't process what I send" (and so there is messages queuing)

*Pattern 6: the cache-aware split pattern*

image::voxxed_68.jpg[]

* we split the order, then *I send ONLY the useful part*, then I only send back what has changed 

*Pattern 7: the $-friendly actor directory pattern*

* save about 40% cache memory (to find the correct core to contact)

===== Modern software roadmap

image::voxxed_69.jpg[]

-> This sentence says that the software guys waste performance efforts made by the hardware guys.

image::voxxed_70.jpg[]

* architect should first think concurrently
* unfortunately our human brains are made to think sequentially
* so *develop monothreaded*
* but then *run parallel*, and *execute reactive*

===== Demo

It shows that it is possible to monitor *without impacting the performances*.

===== Resources

image::voxxed_71.jpg[]

=== Integrating microservices by accepting the data dichotomy

Presented by *Damien Gasparina*, engineer and an open-source enthusiast working for Confluent.

==== Abstract

When building a microservices-based systems, we don’t generally think too much about data. +
If we need data from another service, we ask for it. +
This pattern works well for whole swathes of use cases, particularly ones where datasets are small and requirements are simple. +
But real business services have to join and operate on datasets from many different sources and this can be slow and cumbersome in practice.

These problems stem from an underlying dichotomy. +
*Data systems are built to make data as accessible as possible* - a mindset that focuses on getting the job done. +
*Services, instead, focus on encapsulation* - a mindset that allows independence and autonomy as we evolve and grow. +
But these two forces inevitably compete in most serious service-based architectures.

Understanding and accepting this dichotomy is an important part of designing service-based systems at any significant scale. +
In this talk, we will explain how to make use of a shared, immutable sequence of records to balance data that sits inside their services with data that is shared, an approach that allows the likes of Uber, Netflix, and LinkedIn to scale to millions of events per second.

==== Notes

____
A good architecture is before all an architecture that can evolve over time
____

For that:

* autonomy
	** independence is where services get their value
* allows scaling
	** you can scale monolith, but that very difficult to do *in terms* of people (lots of developers) +
	That's where *microservices* come: *to allow people to work efficiently together*
* Services work best in a single bounded context
	** that's generally possible for technical services (like SSO)
	** but is much more difficult for business services
+
image::voxxed_72.jpg[]
+
(check the "authorisation" service)
	** we need encapsulation to hide internal state. Be loosely coupled.

Database magnify the data

image::voxxed_73.jpg[]

[IMPORTANT]
====
Data systems are about exposing data. +
Services are about hiding data.
====

IMPORTANT: Microservices shouldn't share a database

Data is tend to amplify the "data-service" problem -> when your service is finally principally use to expose data

Reality: data diverges over time

* the more mutable copies, the more data diverge over time
+
image::voxxed_74.jpg[]

Forces competing in the systems world: *Accessibility vs coupling vs divergence*

SO, WHAT'S THE BETTER WAY?

-> *Event Driven*: interact through events, don't talk to services.

* Request sourcing -> high coupling
* *Event broadcast* -> lowest coupling 
+
image::voxxed_75.jpg[]

We need to share event, and so we need a messaging system for that. +
-> Hence *Kafka*, more than a messaging bus, it's a *streaming platform*.

image::voxxed_75.jpg[]

* Kafka scales very well
* a place to *keep data on the outside*
+
image::voxxed_77.jpg[]

.Kafka: a streaming platform
image:voxxed_78.jpg[]

The [red]*streaming engine* is a big force of the Kafka platform

image:voxxed_79.jpg[]
image:voxxed_80.jpg[]

* rocksDB as a KV Key Value store

.After Event service, Query service
image::voxxed_81.jpg[]

____
So we have shared storage in the Log, and a query engine layered on top
____

Data storage PLUS query engine = DATABASE +
Is Kafka

image:voxxed_82.jpg[]
image:voxxed_83.jpg[]

A database use a log and hide it. +
But Kafka do the opposite: it exposes its log +
-> it decentralizes responsibility for query processing

image::voxxed_84.jpg[]
image::voxxed_85.jpg[]

So, if you want to *share a database*, *turn it inside out*!

(Very good) Synthesis

image::voxxed_86.jpg[]

==== Resources

image::voxxed_87.jpg[]

Conclusion

* VERY GOOD SLIDES!
* very good and pragmatical talk
* [red]*the best talk on Kafka I ever seen!*

=== Microservices Lessons Learned

Presented by Susanne Kaiser

==== Abstract

The journey from monolith to microservices is different for every organization. +
A variety of challenges come with introducing microservices itself, but also organizational circumstances impacting the transformation that needed to be considered.

In this talk I would like to share some microservices lessons learned from a startup perspective - and in hindsight, what to watch out for if starting the journey again.

==== Notes

REX on Susanne startup, which she was CTO.

It was a big monolith.

image::voxxed_88.jpg[]

.The motivation for microservices
image::voxxed_89.jpg[]

*Decomposition strategy*

image::voxxed_90.jpg[]

Mise en avant (une fois encore) de *l'architecture hexagonale* pour la décomposition

image:voxxed_91.jpg[]
image:voxxed_92.jpg[]

BUT, was a bit too many steps at once, too difficult to begin with

image::voxxed_93.jpg[]

And so, another way to start:

image:voxxed_94.jpg[]
image:voxxed_95.jpg[]
image:voxxed_96.jpg[]

*Cross-cutting concerns*

* *authorization*: need to be a unique service
	** Handle them as early as possible
	** avoid to build a distributed monolith, and to do so *use one stable common contract*
+
image::voxxed_97.jpg[]
image::voxxed_98.jpg[]

*Service interaction*

image::voxxed_99.jpg[]

* Request driven: direct call to the API

*How to manage shared data?*

image::voxxed_100.jpg[]

* Event not only used for notification, but also to share state

.Source of Truth
image::voxxed_101.jpg[]

-> extremly important

And hence *Kafka* (again and again)

image::voxxed_102.jpg[]

* messaging system
* storage system
* streaming platform (through *Kafka streams*)

image:voxxed_103.jpg[]
image:voxxed_104.jpg[]

Use *materialized views* with Kafka Streams (as a *State Store*)

image::voxxed_105.jpg[]
image::voxxed_106.jpg[]

And again, microservices is complex, checkout their associated infrastructure

image::voxxed_107.jpg[]

[quote, Susanne moto again]
____
Build the things that differentiate you, offload the things that don't
____

You have to differentiate from your competitors (we feel that Susanne was the CTO of a startup (_Just Social_))

*Summary and lessons learned*

image::voxxed_108.jpg[]

-> road to microservices are a journey

* start small
* consider managed services to offload infrastructure complexities (again! As in the previous conf)
* every journey is different, *there is no UNIQUE solution to handle them all*
* you need to have the management on your side to take the microservice road

==== Conclusion

Super talk ! +
Slides à récupérer et conserver, quasiment tout est à garder. +
-> Susanne a fait les slides à la main ! (mouse drawing)

Contact pour Susanne : @suksr

=== Running Kafka in Kubernetes - a practical guide

Presented by Katherine Stanley, from IBM

==== Abstract

Apache Kafka is a very popular choice publish/subscribe messaging and event streaming in modern Cloud Native application. +
These reactive and event-driven applications are increasingly containerised and deployed to Kubernetes. +
This session will cover the practical aspects of deploying Kafka to a Kubernetes environment, from configuring resources to deploying applications.

We will show an example deployment of Kafka on Kubernetes, including the Kubernetes objects to use and the resource considerations you must make when configuring your deployment. +
The session will highlight useful metrics to consider when creating Kubernetes health checks and pitfalls to avoid.

Finally we will demonstrate how to connect an application to your Kafka deployment. This will include the additional objects required to expose Kafka to applications running externally to your Kubernetes cluster.

==== Notes

Kat spotlights *IBM Event Streams*.

image::voxxed_109.jpg[]

Techno mises en avant : Kafka, Docker, Kuberntes, Istio

Kafka cluster and the notion of Replica leader

image::voxxed_110.jpg[]

*Kubernetes*: pods containing containers, with a coordinating service above all.

image::voxxed_111.jpg[]

-> If the pod needs a persistent storage, hence Kafka, we do it through a *persistent volume*.

.Performance tip
NOTE: Keeps Zookeeper (for metadata) next to Kafka, because of the frequent exchanges between them.

Kubernetes metrics:

* *Liveness*
	** is container running? +
	failure -> restart container
* *Readiness*
	** ready to receive traffic +
	check in-sync replicas

.Definition from the workshop "Deploy Microservices on Kubernetes and Istio"
[NOTE]
====
Kubernetes supports *monitoring applications* in the form of *readiness* and *liveness* probes. +
Health checks can be performed on each container in a Pod. 

* *Readiness* probes indicate when a Pod is *"ready" to serve traffic*. +
If a readiness check fails the container will be marked as not ready and will be removed from any load balancers.

* *Liveness* probes indicate a *container is "alive"*. +
If a liveness probe fails multiple times the container will be restarted. +
Liveness probes that continue to fail will cause a Pod to enter a crash loop. 
====

image::voxxed_112.jpg[]

=== Cloud Native Java, part deux

Presented by Josh Long (Pivotal)

==== Abstract

You know what nobody has ever said to me? +
"I wish you'd covered even more in your 45 minute 'Cloud Native Java' talk!" And I listened! In this talk, we'll look at Spring Cloud.next to support modern microservices development, focusing on the things that really matter (or, at least, the things we've got cooking in Spring Boot 2.0 and Spring Cloud Finchley.

* functions-as-a-service with Spring Cloud Function and Project RIff
* functional reactive REST endpoints (totally different meaning for "function" here, though) reactive programming with Spring Framework 5. Leverage flow control at every layer and make the most efficient use of every CPU when doing input/output. You're going to need every bit of efficiency that you can get after you've installed the patches for Spectre and Meltdown!
* Kotlin. Yes, KOTLIN: you wanted Java and I'm giving it to you.. in libraries that I'll use from Kotlin.
* messaging with Apache Kafka. Nothing funny here. It's just awesome.
* Live on the edge with the new, reactive, rate-limiting, proxying, websocket-aware Spring Cloud Gateway
* ASCII art!

==== Notes

.Josh contact (very active on Twitter)
image::voxxed_113.jpg[]

Bientôt, nouveau livre de Josh : _Reactive Spring_ (https://ReactiveSpringBook.io)

*start.spring.io* for the Sprint Initializr

1st Josh's advise: as we are speaking about *reactive stuff*, do NOT choose *SQL stuff* in the initializer...

*Flow Control* = *Back pressure* in the Reactive world

Each thread here is an *Event Loop*.

Mainly a live demo (as he already did before)

*rsockets* are going to be supported on a short future.

=== Data Streaming for Microservices using Debezium

Presented by Gunnar Morling (Red Hat)

==== Abstract

Debezium (noun | de·be·zi·um | /dɪ:ˈbɪ:ziːəm/) - Secret Sauce for *Change Data Capture*

Streaming changes from your datastore enables you to solve multiple challenges: synchronizing data between microservices, maintaining different read models in a CQRS-style architecture, updating caches and full-text indexes, and feeding operational data to your analytics tools.

Join this session to learn what change data capture (CDC) is about and how it can be implemented using Debezium, an open-source CDC solution based on Apache Kafka. Find out how Debezium captures all the changes from datastores such as MySQL, PostgreSQL and MongoDB, how to react to the change events in near real-time, and how Debezium is designed to not compromise on data correctness and completeness also if things go wrong.

In a live demo we'll show how to set up a change data stream out of your application's database, without any code changes needed. You'll see how to sink the change events into other databases and how to push data changes to your clients using WebSockets.

==== Notes

.Gunnar contact (again to contact on Twitter)
image::voxxed_114.jpg[]

*CDC Use Cases*

image::voxxed_115.jpg[]

But also, those use cases:

* microservices Data Prograpation
* extract microservices out of monoliths

And finally:

image::voxxed_116.jpg[]

How to Capture Data Changes?

image::voxxed_117.jpg[]

-> *Dual writes* are a *BAD* idea (failures and prone to *race conditions*)

image::voxxed_118.jpg[]

A better solution: *to monitor the database*

* As a part of this solution, let's [red]*read the database log* for CDC
	** MySQL: binlog
	** Postgres: write-ahead log
	** MongoDB: op log

And so, hence again, *Kafka* -> perfect fit for CDC

image::voxxed_119.jpg[]

Now *Kafka Connect*:

* a framework for *source* ans *sink* connectors
* track offsets
* schema support
* clustering
* rich eco-system of connectors
	** *Debezium* is a set of connectors

.CDC message structure
image::voxxed_120.jpg[]

Debezium set of connectors

image::voxxed_121.jpg[]

Now, let's dip in the streaming part

image::voxxed_122.jpg[]

migrating from monoliths to microservices :

* stream changes to extracted microservice

Again *materialize Aggregate Views*

image:voxxed_123.jpg[]
image:voxxed_124.jpg[]

-> last one is a *good explicative schema of CDC* (and also simple by the way)

*To detect missing or wrong data:*

* constantly *compare record counts* on source an sink side
	** raise alert if threshold is reached
* compare every n-th record *field by field*
	** E.g. have all recors compared within one week

.Leverage the powers of Kafka Connect SMTs (Single Message Transofrmations)
image:voxxed_125.jpg[]

Debezium current status

image::voxxed_126.jpg[]

==== Summary

image::voxxed_127.jpg[]

Mon avis : des infos intéressantes, mais j'ai trouvé le talk de Susanne plus clair.

=== Create API for your databases, Rest, GraphQL, gRPC which one should you choose ?

Presented by Cedrick Lunven, Developer Advocate at DataStax 

==== Abstract

Depending on your use cases you may need to access your databases which different patterns and technologies (CRUD+UI, batch, reactive, IoT, ...).

At DataStax, the developer advocates team implements reference applications for developers. We had the chance to implement multiple approaches and can provide feedback. KillrVideo.com is one of this application, it has been written in 3 languages (Java, C# and Node) and implement API with REST, Grpc and GraphQL.

Though live session, browsing real code, you will see implementation details, lessons learnt and get working source code in Github as takeaway.

==== Notes

.Objectives of the talk
image:voxxed_128.jpg[]

Demo application :

* http://dev/killrvideo.com
* https://killrvideo.github.io/

Data model

image:voxxed_129.jpg[]
image:voxxed_130.jpg[]

For each query in Cassandra you need to have a particular table:

image:voxxed_131.jpg[]
image:voxxed_132.jpg[]

Database access patterns

image::voxxed_133.jpg[]

Tools in action

image::voxxed_134.jpg[]

For the demo, check on GitHub: 

Spring Data is *NOT* used +
-> apparently some issues using Spring Data and Cassandra, but that was principally not needed.

There is a Spring Boot gRPC started, but *NOT* for the last gRPC versions

*REST Drawbacks and advantages*

image::voxxed_135.jpg[]

* MINUS: you can't choose what you want to pick -> you need to take everything (and do big payload) 

*gRPC drawbacks and advantages*

image::voxxed_136.jpg[]

*GraphQL drawbacks and advantages*

image::voxxed_137.jpg[]

To summarize:

image::voxxed_138.jpg[]

Resources: https://github.com/clun/voxxeddays-api

=== Do microservices dream about CQRS-ES, Kafka Stream and BPMN ?

Presented by Cédric Vidal (Quicksign) and Nicolas Romanetti (QuickSign)

==== Abstract

Like many other software vendors Quicksign has chosen to migrate its SAAS platform from an on-premise monolith to a microservices platform in the Cloud.

Using a modern tech stack including Kafka, Kubernetes, the Camunda BPMN engine and some in-house development we have built a Kappa CQRS-ES multi-tenant platform able to execute BPMN workflows that can discover and consume any microservice registered in a Kubernetes backed extended registry that allows content type and protocol negotiation.

Our platform leverages Kafka Streams to dynamically generate from a reactive stream of workflow events a bespoke REST-API (HATEOAS) representation so as to ease our customers’ integration effort and allow fast iterations.

We propose to briefly introduce the audience to BPMN and then expose the rationale that led us to build this architecture, its advantages in terms of agility and scalability.

==== Notes

*BPMN*: Business Process Model Notation

*QuickSign*: B2B2C SAAS solution in white label (?)

An example of BPMN:

image::voxxed_139.jpg[]

* a simple XML file stored in Git

*Kafka* is the backbone of QuickSign *microservices architecture*, and BPMN is its heart.

.We are not Twitter
image:voxxed_140.jpg[]

-> But we are growing!

[red]*Regulators*: we need to *keep logs of everything*

CQRS and Event Sourcing (CQRS-ES)

image::voxxed_141.jpg[]

* again CQRS-ES done using *Kafka Streams*
* Again, *creation of materialized views to materialize some queries*
* several use cases in that schema, in pale blue we have the materialized views

*Camunda* as a BPMN engine

* Camunda is Open Source, with a clean code base BUT has been developped as *working with an old classic and blocking database* (JDBC based).

QuickSign Camunda / Kafka architecture

image::voxxed_142.jpg[]

Why Kafka?

image::voxxed_143.jpg[]

-> but that's not enough! The *key is Kafka Streams*

image::voxxed_144.jpg[]

* All consumers can consume at their own rythm
* Key for Materialized Views: embedded ephemeral disk based KV Store to perist intermediate stream states and query store (Facebook's *RocksSB*)

*How de you route your events?*

image::voxxed_145.jpg[]

* The trick is to make sure all messages related to a given aggregation root and up on the same partition
* that's the harder thing to do with CQRS-ES using Kafka

image:voxxed_146.jpg[]
image:voxxed_147.jpg[]

-> At QuickSign, as shown in the last slide, *a custom Partitioner strategy* is used.

*Now, how do you query your data?*

image::voxxed_148.jpg[]

NOT UP-TO-DATE screenshot here!

* right part (take 2): step 3 is if data is not in P1 and P2 (forward from C1 to C2)

.Finally, QuickSign solution
image:voxxed_149.jpg[]

-> interesting parts here

* One API per customer
* *API "generated" from BPMN*
	** the REST API is fully generated by the BPMN engine, without any modification

*Mon avis* : très bon talk de Cédric ! +
Un architecture bien expliquée, avec de bonnes explications de choix effectués

== WEDNESDAY - workshop

*Schedule*: https://vxdms2018.confinabox.com/byday/wed

=== Deploy Microservices on Kubernetes and Istio

By SFEIR team: Abdennebi Mohamed, Julien Furgerot, Abderrazak BOUADMA and Yann CHENU

==== Abstract

After attending this workshop, you will know and understand:

* The overall Kubernetes architecture: master vs node / api-server, etcd, controllers & kubelet
* The most important Kubernetes objects and their responsibilities: pod, deployment, service, ingress, config, secret, volume
* How to use Istio to deploy applications based on microservices: rolling upgrade, canary and blue/green, * advanced routing
* How to use Istio to increase visibility and security on what you deployed

==== Notes

image::voxxed_150.jpg[]

What is a Kubernetes cluster?

image::voxxed_151.jpg[]

Content of a node:

image::voxxed_152.jpg[]

In Kubernetes, the basis is the *pod* +
The most used pod is one containing *only 1 container*.

image::voxxed_153.jpg[]

3 patterns for *multiple containers in pods*:

image::voxxed_154.jpg[]

* sidecar
* Adapter: Adapter take the user connection, and passes the request to the App Container
* Ambassader: 

IMPORTANT: You guarantee with that (multiple containers in a pod) that *all containers in a pod will run on the same machine*, hence avoiding I/O and perf issues.

image::voxxed_155.jpg[]

* The scalling of the pods is handled by Kubernetes *ReplicaSet*.
* *Deployment* will manage the pod life cycle: if by example I want to deploy v2 instead of v1, the Deployment will deploy a new ReplicaSet for v2, and deletes the old v1 ReplicaSet once done.
* *Ingress* allows you to have a single entry point to the cluster, and will manage HTTP routing.
* To secure all of that, you can create different spaces in Kubernetes, to separate your application from aplications of other teams

===== Kubernetes Internals

Kubernetes was created by Google, which uses containers (lots of!) for now 15 years. +
To manage all those containers, Google created an orchestrator called *Borg*

image::voxxed_156.jpg[]

* All this works with a *Control Loop*
* conf is a resource definition file (.yaml) which is given to *etcd* (???) (distributed among master nodes)
* in Node you have a special component: Kubelet +
This last watches the configuration

-> So resources are only yml

Example of Pod:

image::voxxed_157.jpg[]

* *spec* part is the definition of the resources
	** currently Kubernetes uses Docker, but it can technically use anything that launches processes (like a VM image)

image::voxxed_158.jpg[]

* `kubectl explain pod` gives you life info on the pod

image:voxxed_159.jpg[]
image:voxxed_160.jpg[]

* In *Deployment* section, the *template* section gives info on the pod definition

===== The labels game

image::voxxed_161.jpg[]

* this concept of *labels* is the way Kubernetes uses to link different ReplicaSet.

image::voxxed_162.jpg[]

===== Services

Services provide *stable endpoints for Pods* based on a set of *labels*.

image::voxxed_163.jpg[]

* *service B* is on several pods, and has 1 IP. Accessing this last allows to load balance to the different pods.

Services can have different types:

* *Cluster IP*
+
image:voxxed_164.jpg[]

* *NodePort*
+
image:voxxed_165.jpg[]
+
	** uses a *kubeproxy*, automatically defined, allowing to calls this pod on a given port from any other pod

* *LoadBalancer*
+
image:voxxed_166.jpg[]

The other way (not using a host platform like Google) to expose your application through standard ports is to use *Ingress*:

image::voxxed_167.jpg[]

* Will route your request based on the URL path

===== Rolling-upgrade

How to upgrade your pods without interruption?

image:voxxed_168.jpg[]
image:voxxed_169.jpg[]
image:voxxed_170.jpg[]

* 2/4 Kubernetes will replace one pod of your application
* 3/4 and 4/4: once 2/4 is done, Kubernetes will continue replacing v1 pods with v2 pods

===== Istio

.Microservices drawbacks
image::voxxed_171.jpg[]

To answer to those drawbacks, we can use tools like *Spring Cloud* or *Netflix OSS*

* Hystrix
* Ribbon
* Eureka
* Zuul: edge gateway

-> But all those tools are for the Java world, what to do for other techno? +
Answer is *Service Mesh*

image::voxxed_172.jpg[]

.Istio
image::voxxed_173.jpg[]

* With Istio you don't need Hystrix (and in addition is more powerful)
* Istio is a Service Mesh with Zero Application Code Changes

.Istio Components
image::voxxed_174.jpg[]

* Istio transparently adds a proxy for each service
* Those proxies will catch all ingoing and outgoing traffic
* They will also transmit different metrics (telemetry) to the Mixer
* *Citadel* is a component responsible for handling and creating keys and certificates for TLS

*Traffic management* and definition of *VirtualService, DestinationRule, subsets and Policies*:

image:voxxed_175.jpg[]
image:voxxed_176.jpg[]
image:voxxed_177.jpg[]

* This kind of traffic management is not possible with only Kubernetes (this feature is NOT available)

NOTE: Istio has some impact on the performances

== Buzz words

"Main theme": *splitting the monolith*

* *Service Mesh*, et plus particulièremnet *Istio* +
En voici une définition tirée de cet article d'Octo : 
+
----
Le Service Mesh désigne une plateforme chargée d’assurer la sécurité, le routage et la traçabilité des communications entre applications microservices déployées de façon dynamique dans des conteneurs.
----

* *Kafka*, and *Kafka Streams*. The whole platform from Confluent being now and more and more used as a Source of Truth
	** and the use of Kafka for *Materialized Views*
* [RED]*Hexagonal architecture* (with DDD)
* *Kubernetes* and its tools like *Helm*, *Nexus*, *Skaffold*

* A bit of *12 Factors application*

== Synthesis

Best speakers (my opinion):

* *Susanne Kaiser*: @suksr
* *Damien Gasparina*: @DamienGasparina

Best talks I saw:

* _Integrating microservices by accepting the data dichotomy_, by Damien
* _Microservices Lessons Learned_, by Susanne
* _Do microservices dream about CQRS-ES, Kafka Stream and BPMN?_ by Cédric Vidal

I didn't see but friends told me it was great:

* https://vxdms2018.confinabox.com/talk/LLD-3111/10_tips_for_failing_at_microservices[10 tips for failing at microservices] par David Schmitz +
For what I was told David is a german guy with a lot of humor, who knows how to insist on important points.

Au final on peut dire que :

* Avoir un *Message Broker* est poussé dans toutes les solutions (= *Kafka*)
* l'*Architecture Hexagonale* se répand un peu partout, bien aidée par la généralisation du *DDD*, dont les avantages sont maintenant reconnus
* _"consider managed services to offload infrastructure complexities"_ : en microservices, cela devient une bonne pratique de plus en plus répandue, que de sortir certaines *complexités* liées à l'infra (comme le cache) dans un *service managé*.

NOTE: More and more speakers insist on being *contacted on Twitter*.

== Misc

.Scène / format vidéo utilisé par le salon pour l'enregistrement des talks
image::voxxed_video_scene_format.jpg[]