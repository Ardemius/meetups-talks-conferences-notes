= 2022/06/22 - JavaDay au Paris JUG: Le futur de Java en 2022
Thomas SCHWENDER <icon:github[] https://github.com/Ardemius/[GitHub] / icon:twitter[role="aqua"] https://twitter.com/thomasschwender[@thomasschwender]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images
:source-highlighter: highlightjs
:highlightjs-languages: asciidoc
// We must enable experimental attribute to display Keyboard, button, and menu macros
:experimental:
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 4
// To number the sections of the table of contents
//:sectnums:
// Add an anchor with hyperlink before the section title
:sectanchors:
// To turn off figure caption labels and numbers
:figure-caption!:
// Same for examples
//:example-caption!:
// To turn off ALL captions
// :caption:

toc::[]

* JavaDay organisÃ© par le Paris JUG, au centre des congrÃ¨s du Jardin d'Acclimatation, le 22/06/2022
* Description de l'Ã©vÃ¨nement : https://javaday.parisjug.org/

== 09h15	: Accueil des participants

image:20220622_JavaDay_00.jpg[]

== 10h00 : Java en 2022 : profiter de Java 17

Talk donnÃ© par Jean-Michel Doudoux

.Abstract
----
Beaucoup dâ€™applications utilisent encore Java 8 mais Java a beaucoup Ã©voluÃ© depuis notamment avec la diffusion de deux versions LTS.

Lâ€™objectif de cette prÃ©sentation est de revenir sur certaines de ces nombreuses Ã©volutions de Java, notamment rÃ©centes afin dâ€™en profiter dans nos applications. Au-delÃ  des Ã©volutions syntaxiques et dans les API, ce sera aussi lâ€™occasion de justifier la migration vers des versions plus rÃ©centes de Java.
----

=== Le passÃ©

On commence par des rappels sur les grandes fonctionnalitÃ©s des prÃ©cÃ©dentes versions de Java depuis Java 8

    * Java 8
    * Java 9
        ** JShell
        ** VarHandle
        ** *Et les fameux modules* : une fonctionnalitÃ© impactante et trÃ¨s controversÃ©ee
            *** et dont la mise en oeuvre implique des contraintes (visibilitÃ©, accessibilitÃ©, organisation du code, ...)
        ** crÃ©ation d'un JRE personnalitÃ© avec JLink
        ** `var` pour faciliter la dÃ©finition de variables
    * Java 10
        ** bien meilleur support des containers
    * Java 11
        ** version LTS
    * Java 14
        ** refonte des switch expression
            *** le switch devient une vraie expression. +
            On peut donc faire `String libelle = switch...` +
            image:20220622_JavaDay_01.jpg[]
    * Java 15
        ** blocs de texte
            *** exprimer une chaÃ®ne de caractÃ¨res littÃ©rale multiligne
        ** Helpful NullPointerException
    * Java 16
        ** pattern matching pour instanceof
        ** nouveau type de classe, les *records*
            *** son but est d'encapsuler des variables de faÃ§on immuable
    * Java 17
        ** les classes scellÃ©es (`sealed` classes) +
        image:20220622_JavaDay_02.jpg[]
        ** nouvelle version LTS
        ** diffusÃ©e en septembre 2021
        ** changement de licence d'Oracle (qui remet un peu de gratuitÃ© dedans)
    * Java 18
        ** diffusÃ©e en mars 2022
        ** UTF-8 par dÃ©faut (enfin !), sauf pour la sortie console
        ** le mÃ©canisme finalize est dÃ©prÃ©ciÃ©

=== Le prÃ©sent

Comment "vendre" Ã  la PROD (les OPS) la migration Ã  une version rÃ©cente de Java ? +
-> les bons arguments : *performance* et *sÃ©curitÃ©*

.Performance
image:20220622_JavaDay_03.jpg[]

.SÃ©curitÃ©
image:20220622_JavaDay_04.jpg[]

Comment "vendre" au management cette fois ? +
-> Les *coÃ»ts*, et d'autres arguments (dont le RGPD)

.Les autres arguments
image:20220622_JavaDay_05.jpg[]

*RÃ¨gles gÃ©nÃ©rales de migration > 8*

    * mettre Ã  jour les outils
    * mettre Ã  jour les dÃ©pendances
    * utiliser jdeps
    * mythe urbain : aucune obligation de modulariser l'application

-> A partir de Java 11 toute version de Java retire des choses

    * `jdeprscan` pour obtenir les API dÃ©prÃ©ciÃ©es du JDK
    * Jetez un oeil Ã  l'*almanac Java* pour vous aider

.migration de Java 8 vers Java 11
image:20220622_JavaDay_06.jpg[]

migration de Java 11 vers Java 17 : 

    * Il est important d'avoir un coverage Ã  100% du code. +
    Pourquoi ? A cause de la nouvelle encapsulation forte des API internes du JDK +
    image:20220622_JavaDay_07.jpg[]

migration de Java 8 Ã  17

=== Le futur

.Les projets futurs de Java
image:20220622_JavaDay_08.jpg[]

* pattern matching pour les switch (en preview dÃ¨s Java 17)

.Et le futur un tout petit peu plus Ã©loignÃ©
image:20220622_JavaDay_09.jpg[]

-> Conclusion : Dans tous les cas, pour profiter de ces nouvelles fonctionnalitÃ©s, il *FAUT* migrer !

-> Ce talk est trÃ¨s proche de celui donnÃ© par Jean-Michel au dernier Devoxx France 2022 ("10 ans de Devoxx France et de Java"), et dont les slides sont disponibles ici : +
https://fr.slideshare.net/jmdoudoux/devoxx-2022-10-ans-de-devoxx-fr-et-de-javapdf

[NOTE]
====
Pour fÃªter les 4000 pages de "DÃ©veloppons en Java", le JavaDay offre 4 millefeuilles Ã  JM ðŸ˜ 

image:20220622_JavaDay_10.jpg[]
====

== 10h50 : RemÃ¨des aux oomkill, warm-ups, et lenteurs pour des conteneurs JVM

Talk donnÃ© par Jean-Philippe Bempel et Brice Dutheil

-> Ce talk a Ã©tÃ© donnÃ© au dernier Devoxx France 2022 +
Il a trait Ã  tous les problÃ¨mes (oomkill) que l'on peut rencontrer quand l'on fait tourner Java dans un container (Kubernetes).

Mes notes de l'Ã©poque sont disponibles ici : +
https://github.com/Ardemius/meetups-talks-conferences-notes/tree/master/202204-devoxx-france#09h30-12h30-242ab-rem%C3%A8des-aux-oomkill-warm-ups-et-lenteurs-pour-des-conteneurs-jvm

=== Partie mÃ©moire et oomkill

.Rappel sur le RSS, le Resident Set Size
[NOTE]
====
La *Resident Set Size* (*RSS*, "taille du jeu rÃ©sident") est la quantitÃ© de mÃ©moire occupÃ©e par un processus contenue dans la RAM. +
RSS permet dâ€™obtenir la taille rÃ©elle du conteneur Kubernetes.
====

.De quoi est composÃ©e la mÃ©moire d'une JVM ?
image:20220622_JavaDay_11.jpg[]

* Pour le *monitoring*, il existe une multitudes de *MBeans* (accessible via *JMX*) +
GrÃ¢ce Ã  cela on aura des infos sur quelques zones mÃ©moires, mais PAS toutes

* Il va falloir utiliser des outils de diagnostic, comme le fantastique *jcmd* +
image:20220622_JavaDay_12.jpg[]

    ** `jcmd $(pidof java) VM.native_memory` +
    image:20220622_JavaDay_13.jpg[]

.Il est important de donner au container plus de RAM que la valeur max de la heap
image:20220622_JavaDay_14.jpg[]

=== Autres problÃ¨mes

* redÃ©marrage du container

* Le JIT et les *compilateurs C1 et C2* :
    ** The JDK implementation by Oracle is based on the open-source OpenJDK project, which includes the HotSpot virtual machine.
    ** It contains 2 conventional JIT-compilers: the client compiler, also called C1 and the server compiler, called opto or C2.

* Avec Kubernetes, plus qu'une notion de CPU, on a une notion de *shares* et *quotas* +
image:20220622_JavaDay_15.jpg[]
image:20220622_JavaDay_16.jpg[]

* *Tuning CPU* : toujours un trade-off entre startup time vs request time
    ** adjust CPU shares  CPU quotas
    ** adjust liveness timeout
    ** use readiness / startup probes

.En conclusion, que faire quant Ã  la mÃ©moire et au dÃ©marrage
image:20220622_JavaDay_17.jpg[]
image:20220622_JavaDay_18.jpg[]

* Le conseil final de JP : TOUJOURS setter la heap (TOUJOURS) 
* Et attention au *RAMPercentage* qui n'est PAS un silver bullet pour rÃ©soudre tous les problÃ¨mes (loin de lÃ )

-> Un talk qui rentre vraiment dans le dÃ©tail du domaine de la performance. +
A utiliser si vous Ãªtes confrontÃ©s aux problÃ¨mes dÃ©crits (ou pour culture gÃ©nÃ©rale et savoir que des solutions existent). Peut paraÃ®tre un rien "abrupte" de prime abord ðŸ˜‰ 

TIP: Je conseille de vous rÃ©fÃ©rer au talk donnÃ© Ã  Devoxx si vous voulez plus de dÃ©tails, car il s'agissait d'une universitÃ© de 3h ðŸ˜‰ 

== 11h40 : SÃ©curitÃ© en Java 17 : les nouveautÃ©s passÃ©es et Ã  venir

Talk donnÃ© par Charles Sabourdin

* Initialement la JVM servait Ã  faire tourner du code qu'on ne connaissait pas sur le navigateur
* DONC la JVM est arrivÃ© avec son propre systÃ¨me de sÃ©curisation pour l'isoler du systÃ¨me

.Java Security Model
image:20220622_JavaDay_19.jpg[]

* Autre info Ã  savoir : pour des *raisons lÃ©gales*, certaines *fonctionnalitÃ©s sont volontairement limitÃ©es*, car jugÃ©es "trop puissantes" dans d'autres pays (surtout dans le cas de la cryptographie)
    ** Un exemple dans un autre monde que Java, la PS2 ne pouvait pas s'exporter partout car jugÃ©e trop puissante. +
    Jetez un oeil Ã  la section 4.2.4 de cet article pour plus d'infos : https://e.20-bal.com/law/18082/index.html
    ** D'oÃ¹ l'usage d'un *Security Provider* dans Java : https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/Provider.html

* *C'est Ã  nous d'indiquer Ã  notre serveur quels types de clÃ©s, quels types de traitement il peut accepter*. Cela afin que le client ne puisse pas forcer un certificat que l'on n'accepte pas.

* Avec le Java 17, le *Security Manager* est maintenant *dÃ©prÃ©ciÃ©*.
    ** Et devrait donc Ãªtre supprimÃ© d'ici peu

== 14h00 : Micronaut AOT pour optimiser vos applications pour le JIT et GraalVM

Talk donnÃ© par CÃ©dric Champeau

* Micronaut est un framework initialement crÃ©Ã© pour les microservices, mais son utilisation a Ã©voluÃ© et est devenu plus gÃ©nÃ©raliste
* Le framework fait un max de choses au build time, en se servant de annotation processing

* Le constat est que *Spring* fait beaucoup de choses au *dÃ©marrage*, ce qui a un *coÃ»t*
    ** Cela fonctionnait bien, MAIS n'Ã©tait pas adaptÃ© au Cloud (beaucoup de "stop" et "kill" puis de "redÃ©marrage"). Ce n'Ã©tait pas fluent du fait du temps pris au dÃ©marrage.
    ** Micronaut supprime les proxy qui sont si chers Ã  Spring
        *** et permet un dÃ©marrage avec une empreinte mÃ©moire trÃ¨s rÃ©duite

* GraalVM est une VM dÃ©veloppÃ©e par Oracle
    ** GraalVM permet de *gÃ©nÃ©rer du code natif* Ã  partir du code Java

* Micronaut : on va faire un max de choses au build, et Ã©liminer tout ce qui est rÃ©flexion et proxy, ce que n'aime PAS GraalVM.

Demo avec https://micronaut.io/launch

    * l'application peut Ãªtre dÃ©ployÃ©e sur tous le Cloud

image:20220622_JavaDay_20.jpg[]

== 14h50 : De Maven 3 Ã  Maven 5

Talk donnÃ© par HervÃ© Boutemy.

* HervÃ© travaille chez Sonatype depuis 3 ans

.Maven 2
image:20220622_JavaDay_21.jpg[]

.Maven 3
image:20220622_JavaDay_22.jpg[]

.Aujourd'hui nous en sommes Ã  Maven 3.8
image:20220622_JavaDay_23.jpg[]

Et tout cela est toujours *basÃ© sur le mÃªme POM v4*.

    * Comme au dÃ©but de Maven 2.0...
    * A quelques diffÃ©rences prÃ¨s : 
        ** dependencyMangement import scope
        ** transitive dependency excludes (wildcard excludes)
        ** prerequisite (run time -> plugin only) vs enforcer (build time)
        ** properties : `${project.build.sourceEncoding}`, etc.

Et on ne peut pas le faire Ã©voluer CAR il est utilisÃ© par TOUT le monde.

.Le plan pour relancer les possibilitÃ©s d'Ã©volution de Maven
image:20220622_JavaDay_24.jpg[]

.Avec Maven 4, un POM *simplifiÃ©* va Ãªtre mis en place
image:20220622_JavaDay_25.jpg[]

* avec Maven 4, plus besoin d'indiquer la version de chaque sous-module, celle-ci est dÃ©duite du pom parent.

* Le *Maven wrapper* est directement issu du Gradle wrapper qui a Ã©tÃ© mis Ã  disposition en licence Apache
    ** `mvn wrapper:wrapper` -> on demande l'install du wrapper dans le projet
        *** ajout d'un rÃ©pertoire *wrapper* dans le projet, ainsi que les autres Ã©lÃ©ments du wrapper

* Autre fonctionnalitÃ© qui a Ã©tÃ© donnÃ© Ã  Maven, le *Maven Build Cache*
    ** cette fonctionnalitÃ© a Ã©tÃ© dÃ©veloppÃ© Ã  la base par Deutsch Bank
    ** on calcule l'empreinte du code de toutes les sources, et si aucune modification n'a Ã©tÃ© dÃ©tectÃ©e, on va utiliser le contenu du cache +
    image:20220622_JavaDay_26.jpg[]
    ** ce cache est par dÃ©faut cachÃ© dans le .m2
    ** Si cela vous intÃ©resse, *attendez la sortie de Maven 3.9*

* *Maven Daemon* (`mvnd`) : correspond Ã  une rÃ©flexion sur l'optimisation des build Maven
    ** permet des *build parallÃ¨les* afin d'utiliser tous les coeurs de la machine
    ** plus de problÃ¨me du "mixte d'output" (qui rendait trÃ¨s compliquÃ©e la lecture du build)

.En rÃ©sumÃ©
image:20220622_JavaDay_27.jpg[]

* Maven 3.9 pour l'Ã©tÃ© 2022
* Maven 4.0.0-alpha-1 pour Q3 2022
* Pour le Maven Build Cache, il faudra attendre la version 3.9

* Nouveau plugin *Buildplan*, hÃ©bergÃ© dans MojoHaus, permettant d'afficher le plan de build de Maven
    ** Plugin dÃ©veloppÃ© par Jean-Christophe Gay
    ** permet de comprendre comment les goals sont associÃ©s Ã  vos exÃ©cutions

[TIP]
====
Si l'on souhaite *participer au dÃ©veloppement communautaire de Maven*, contactez HervÃ© !

Des Hackegarten sont organisÃ©s rÃ©guliÃ¨rement (tous les mois ?) pour mettre le pied Ã  l'Ã©trier (voir si Twitter le Hack.Commit.Push https://twitter.com/hackcommitpush)
====

NOTE: HervÃ© suite Ã  une question : OUI, on va avoir maven daemon AVEC le Maven Build Cache +
-> Et le rÃ©sultat est impressionant ðŸ˜‰ 

== 16h00 : RÃ©mi Forax : Valhalla: Vers de nouveaux generics universels et specialisables

.Si votre boÃ®te ne sait pas quoi faire de ses sous, parlez-lui de la taxe d'apprentissage
NOTE: *Taxe d'apprentissage*, ne pas hÃ©siter Ã  orienter vos boÃ®tes vers l'universitÃ© Gustave Eiffel

* RÃ©mi est maÃ®tre de conf ET dÃ©veloppeur Open Source pour le projet ASM
    ** ASM est le projet derriÃ¨re TOUTTEEEEE la gÃ©nÃ©ration de bytecode cÃ´tÃ© Java, et n'est maintenu que par 2 "pauvres franÃ§ais" comme le dit RÃ©mi ðŸ˜… 

Projet Valhalla (*Value classes*)

    * on en est au 4e proto
    * objectifs : 
        ** *abstraction for free* : no allocation of intermediary objects
        ** *Improve information density* : no header, use immediate value (no pointer) +
        image:20220622_JavaDay_28.jpg[]

Valhalla : *"je veux une classe pour dÃ©crire des types primitifs, MAIS je veux que ce soit une classe"*

    * et je ne veux PAS payer le coÃ»t d'abstraction : oÃ¹ pour stocker juste un int, on se retrouve Ã  devoir gÃ©rer un header coÃ»tant 32 bits + 64 bits (et en sachant qu'on va tout devoir aligner sur 64 bits du fait de l'architecture Intel)

En fait, on veut *manipuler des valeurs SANS pointeur*

    * donc, dÃ©jÃ , je n'ai *pas de null*
    * mais perdre la notion de pointeurs, c'est perdre Ã©normÃ©ment de choses (utiles) en Java

.flattening (applatissement des valeurs)
image:20220622_JavaDay_29.jpg[]

.2 types de value class
image:20220622_JavaDay_30.jpg[]

La machine virtuelle ne voit pas les classes paramÃ©trÃ©es (*erasure*), MAIS le compilateur les voit.

* notion de *SpecializationAnchor*

.regardons le bytecode
image:20220622_JavaDay_31.jpg[]
image:20220622_JavaDay_32.jpg[]

.Pour rÃ©sumer
image:20220622_JavaDay_33.jpg[]

-> C'est comme Ã§a qu'il faudra Ã©crire le bytecode une fois qu'on aura la VM patchÃ©e...

image:20220622_JavaDay_34.jpg[]

.SpecializationAnchor object
image:20220622_JavaDay_35.jpg[]

.Pour rÃ©sumer "bis"
image:20220622_JavaDay_36.jpg[]

-> Talk mÃ©ritant d'Ãªtre repris tranquillement chez soi ðŸ˜… 

== 16h50 : Panel de discussions avec les speakers

* RÃ©mi : c'est *extrÃªmement bien d'avoir de la compÃ©tition en termes d'implÃ©mentation*
    ** RÃ©mi dit cela suite Ã  une question sur le nombre de projets en cours cÃ´tÃ© JVM ET dans le "monde statique" (GraalVM qui fait un max de choses au build).
    ** En gros la question Ã©tait "Vers oÃ¹ va Java ? JVM ou statique ?"



